<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Underlinee</title>
    <description></description>
    <link>http://underlinee.github.io/</link>
    <atom:link href="http://underlinee.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 01 Apr 2018 15:20:35 +0900</pubDate>
    <lastBuildDate>Sun, 01 Apr 2018 15:20:35 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>유지보수 가능한 코딩의 기술 - 클린코드의 비밀</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;코드 단위를 짧게 하라&lt;/h2&gt;
&lt;p&gt;단위(메서드)는 짧을수록 분석, 테스트, 재사용하기가 좋습니다. 코드 단위는 15라인을 넘어가지 않게 작성합니다. 메서드를 추출하거나 메서드를 메서드 객체로 대체(Replace Method with Method Object) 리팩터링 기법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;코드 단위는 간단하게 짜라&lt;/h2&gt;
&lt;p&gt;분기가 적을 수록 단위를 분석/테스트하기 더 쉽습니다. 복잡도를 객관적으로 산출하는 가장 직관적인 방법은 코드 조각을 지나는 분기의 수를 세어보는 것입니다. 본기점 개수 + 1을 맥캐브 복잡도라고 합니다. 맥캐브 복잡도는 5 이하로 제한합니다. 이를 어기는 경우 중 조건문 체인이 있는 경우가 많은데, 조건을 다형성으로 대체(Replace Conditional with Polymorphism) 리팩터링 기법을 사용할 수 있습니다. 다만 여러 클래스가 코드로 흩어지는 단점은 있습니다. 확장성이냐 간결함이냐, 선택은 개발자의 몫입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;코드는 한 번만 작성하라&lt;/h2&gt;
&lt;p&gt;뭐 하나 고치려면 사본마다 한 번씩 손을 대야 하니 소스 코드 중복은 무조건 피하는 게 상책입니다. 중복되는 부분에 메서드 추출 이나 상위 클래스 추출(Extract Superclass) 기법을 사용합니다. 절대 코드가 바뀌지 않을 거란 생각은 미신에 불과합니다. 복사를 허용하는 건 훗날 누군가 사고를 친 이후 맞닥뜨려야 할 리스크를 인정하는 행위와 다름없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;단위 인터페이스를 작게 하라&lt;/h2&gt;
&lt;p&gt;파라미터가 적은 단위는 재사용, 테스트하기 편합니다. 단위당 파라미터 개수를 4개 이하로 제한하도록 합니다. 파라미터 객체를 만들어서 파라미터를 한데 모아 객체를 만드는 기법으로 수정할 수 있습니다. 큰 인터페이스를 리팩터링해도 여전히 다른 메서드에 많은 파라미터를 넘길 수 밖에 없는 경우가 있을 수 있습니다. 쉬운 작업은 아니지만, 메서드 내부에서 벌어지는 일들을 계속 분할하면서 파라미터를 별개로 조작하는 방식으로 접근해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;관심사를 모듈(클래스, 인터페이스) 로 분리하라&lt;/h2&gt;
&lt;p&gt;느슨하게 결합된 모듈이 고치기 쉽고 시스템을 더욱 모듈화하는 방향으로 이끕니다. 덩치 큰 클래스가 나타나지 않도록, 개별 모듈로 나누어 일을 시키고 구현 상세는 인터페이스 안으로 감춥니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;아키텍처 컴포넌트를 느슨하게 결합하라&lt;/h2&gt;
&lt;p&gt;느슨하게 결합된 최상위 시스템 컴포넌트가 수정하기 더 쉽고 시스템을 모듈화할 여지가 많습니다. 가능한 캡슐화하여 다른 컴포넌트 모듈에 호출을 받는 형태로 공개된 모듈 내부의 상대적인 코드량을 최소화합니다. 개발 초기부터 컴포넌트의 역할의 경계선을 확실히 긋고 컴포넌트간 의존성을 적게 해야합니다. 이 책은 아키텍처를 다루지는 않지만 하나만 언급한다면, 느슨하게 결합한 시스템의 특징은 규약에 더 의존하고 상세 구현부엔 덜 의존한다는 점입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;아키텍처 컴포넌트의 균형을 잡아라&lt;/h2&gt;
&lt;p&gt;컴포넌트가 넘치거나 모자라지 않게 크기를 거의 비슷하게 균형을 맞춰 모듈화한 아키텍처는 관심사를 분리할 수 있고 고치기가 쉽습니다. 최상위 수준 컴포넌트 개수와 상태적 크기의 균형을 잡습니다. 시스템 로직이 너무 많은 것을 매우 큰 컴포넌트 몇개에 넣고 다른 작은 컴포넌트가 여럿 배치되어 있다면 컴포넌트 균형이 어긋난 것입니다. 이를 위해 시스템 도메인을 명확히 알고 일관되게 적용하도록 기능을 컴포넌트에 올바르게 분류해야 합니다. 일관성이 결여된 아키텍처는 나쁜 아키텍처입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;코드베이스를 작게 하라&lt;/h2&gt;
&lt;p&gt;코드베이스는 소스 코드 뭉치로 컴파일 및 배포를 독립적으로 수행하는 단위 입니다. 코드 베이스의 덩치 큰 시스템은 분석, 수정, 테스트할 때 코드가 더 많이 필요해서 유지보수가 쉽지 않습니다. 또 많은 사람이 동원되고 설계는 복잡하며 수행기간은 깁니다. 결국 프로젝트 실패 가능성을 높이게 됩니다. 코드 베이스가 커지는 걸 막고 시스템 크기를 적극적으로 줄어야 합니다. 이를 위해서 기능 추가에 대해 대가를 협의하면서 맞서야 하면, 기준을 표준화하여 프로그램 로직과 움직임을 일관적으로 유지해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;테스트를 자동화하라&lt;/h2&gt;
&lt;p&gt;테스트를 자동화하면 수정한 결과를 거의 실시간으로 피드백 받을 수 있습니다. 테스트 케이스에서는 정상 케이스, 특이 케이스를 모두 테스트하고, 테스트 코드를 제품 코드 처럼 관리해야 합니다. 제품 코드와 테스트 코드 비율을 1:1로 하는 것을 권장합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;클린 코드를 작성하라&lt;/h2&gt;
&lt;p&gt;새로운 팀원이 들어와도 생산적으로 근무하기 위해 코드베이스를 클린한 상태로 유지해야 합니다. 클린 코드는 곧 유지보수 가능한 코드라서 유지보수성이 개선됩니다. 개발자 7대 “보이 스카우트 규칙”은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 단위 수준의 코드 악취를 남기지 말라
2. 나쁜 주석을 남기지 말라.
3. 주석 안에 코드를 남기지 말라
4. 죽은 코드를 남기지 말라
5. 긴 식별자 이름을 남기지 말라
6. 매직 상수를 남기지 말라
7. 제대로 처리 안 한 예외를 남기지 말라
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=98546964&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/9854/69/cover/k292535351_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Mar 2018 03:43:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/31/9791160500783.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/31/9791160500783.html</guid>
        
        <category>클린코드</category>
        
        <category>유지보수</category>
        
        <category>리팩토링</category>
        
        <category>테스트</category>
        
        
        <category>DevBook</category>
        
      </item>
    
      <item>
        <title>책 읽는 뇌 - 독서와 뇌, 난독증과 창조성의 은밀한 동거에 관한 이야기</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;독서는 선천적인 능력이 아니다&lt;/h2&gt;
&lt;p&gt;인류가 독서를 발명해 낸 것은 불과 수천년 전이다. 인간은 이 발명품을 통해 뇌 조직을 재편성했고 그렇게 재편성된 뇌는 인간의 사고 능펵을 확대시켰으며 그것이 결국 인지 발달을 바꾸어 놓았다. 독서는 인류 역사상 최고의 발명품이며 역사의 기록은 그 발명의 결과 중 하나라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;독서를 하는 동안&lt;/h2&gt;
&lt;p&gt;우리는 자의식을 버리고 다른 사람, 다른시대, 다른 문화의 의식으로 넘어간다. ‘넘어가다(passing over)’ 라는 표현은 신학자 존 던이 사용한 말로, 아주 짧은 시간 동안 다른 사람의 의식에서 비롯된 전혀 다른 관점을 시도해 보고 거기에 동화되어 결국 이입하는 프로세스를 묘사하는 말이다. … 이러한 노출을 통해 우리의 생각이 평범한 동시에 고유하다는 것을 배우게 되고 각자 개별적인 존재이지만 결코 혼자가 아니라는 사실을 깨닫게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;모든 독서 애호가들은 하나의 테마를 공유하고 있다&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;독서를 배우면 다시 태어나게 된다… 그러면 다시는 그렇게 외롭지 않을 것이다. - 루머 고든&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;책 속에서 나는 다른 세상뿐 아니라 나 자신으로의 여행을 했다. 내가 누구인지, 무엇이 되고 싶은지, 무엇을 열망하는지 그리고 나의 세계와 자신에 대해 감히 무엇을 꿈꿀 수 있는지 배웠다. 그렇지만 많은 시간, 내가 아는 모든 사람들과 다른 차원에서 존재했다는 느낌도 들었다. 깨어나는 순간이 있는가 하면 잠이 든 순간도 있었다. 그리고 책이 있었다. 무엇이든 가능할 것 같았고 실제로도 자주 그러했던 일종의 평행 세계, 내가 비록 풋내기일지언정 완전히 이방인은 아니었던 세상. 진정한 진짜 나의 세상. 나의 완벽한 섬. - 애너 퀸들런&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;내가 학교에 다니게 된 것은 아버지의 소원 때문이었다. 당시에는 흔하지 않은 요청이었다. 여자 아이들은 학교에 다니지 않았으니까… 나 같은 아이에게 교육이 무슨 소용이었을까? 나는 갖지 못한 것밖에 말하지 못한다. 그것을 내가 가졌던 것에 견주어 재 보고 그 차이 안에서 비참함을 느낄 뿐이다. 그렇지만, 그렇지만… 바로 그런 이유 때문에 난생 처음 나는 집에서 멀리 떨어진 길 너머에 무엇이 있는지 보러 갔던 것이다. - 저메이카 킹케이드&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;뇌가 독서를 배우는 방법&lt;/h2&gt;
&lt;p&gt;아이의 뇌는 생각보다 훨씬 빨리 독서를 준비한다. 유아 시절에 알게 된 감각, 개념, 언어 등 거의 모든 종류의 원재료를 동원해 사용한다. 뇌의 보편적 독서 시스템을 형성하게 될 주요 구조들의 사용방법을 배우는 것이다. … 문자 언어를 듣는 것과 사랑받는 느낌이 연합됨으로써 기나긴 학습 과정이 진행될 수 있는 최고의 토대가 마련되기 때문이다. 인지과학자나 교육학 박사라도 그보다 나은 환경은 조성해 줄 수 없다. … 유치원에 다니는 네다섯 살의 아이들은 글로 씌어진 단어가 말로 발음되는 구어 단어를 나타낸다는 사실을 터득한다. 구어 단어는 음성으로 이루어져 있으며 보다 중요하게는 문자가 그 음성을 전달한다는 사실을 알게 되는 것이다. … 유아들은 우선 문장 안에서 무엇이 단어인지 인지한 다음, 단어 안에 있는 음절을 인지하고 마지막으로 단어 안에서 음소가 분절될 수 있다는 사실을 서서히 인지해 나간다. … 무수히 많은 아이들은 난생 처음 책을 읽는 경험을 한다. 반쯤은 외우고 반쯤은 해독할 수 있는 제일 좋아하는 책을 어느 순간 갑자기(갑작스럽게 보인다) 혼자서 읽게 되는 놀라운 경험 말이다.&lt;/p&gt;

&lt;p&gt;유년기의 독해력 발달에 중요한 영향을 미치는 것은 기억, 예측, 추론 다음에 오는 것, 즉 감정을 느끼고 이입하는 것이다. 이를 통해 보다 완벽한 독해를 하게 되고 어서 빨리 책장을 넘기고 싶어진다. … 유창한 독서를 시작한 어린 독자들은 은유를 통해 읽은 내용의 겉모습 아래 숨겨진 작가가 전달하고자 하는 숨을 뜻을 간파하는 방법을 배운다. 단순히 텍스트를 마스터하는 단계에서 텍스트 아래 감춰진 것을 발견하는 숙련된 독서가의 단계로 넘어간다. … 우리는 인생 경험을 실어 텍스트를 이해하고 텍스트는 삶의 경험을 뒤바꿔 놓는다. 독서 발달의 끝이란 존재하지 않는다. 끝없는 독서의 이야기는 앞으로도 끝없이 어질 것이며 매 순간 뇌와 독자를 변화시키고 눈과 혀와 단어와 작가를 남겨둔 채 ‘싱싱하고 푸르른 진실이 솟구치는’ 새로운 곳을 향해 전진해 나갈 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;독자에게, 마지막으로 떠오르는 생각&lt;/h2&gt;
&lt;p&gt;요컨데, 독서 발달의 자연사는 독서가 가장 고차원적이고 가장 심오한 수준에 이르는 과정을 그린 지극히 희망적이고 교훈적인 이야기다. 그것은 수천 년 전, 인류의 조상 중 몇몇이 신경세포의 대담한 적응 능력을 이용해 점토판과 파피루스 두루마기에 금전적인 빚과 갈망하는 바를 적어 보전했기에 비로소 우리에게 알려지게 된 문화 속에서 시작된 이야기이며 장엄한 동시에 때에 따라서는 가슴 찡하고 적지 않게 머리가 숙여지는 이야기다.&lt;/p&gt;

&lt;p&gt;인류가 텍스트를 넘어 도약하게 된 사연을 들려주는 책이라면 마지막 문장이 있어서는 안 될 것 같다. 따라서 친애하는 독자여, 마무리는 당신의 몫이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=4170699&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/417/6/cover/8952211936_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Mar 2018 09:12:59 +0900</pubDate>
        <link>http://underlinee.github.io/book/2018/03/28/9788952211934.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/book/2018/03/28/9788952211934.html</guid>
        
        <category>sql</category>
        
        <category>queryplan</category>
        
        <category>explain</category>
        
        
        <category>Book</category>
        
      </item>
    
      <item>
        <title>이펙티브 SQL - 쿼리 플랜 분석하기</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;사용 중인 시스템의 쿼리 분석기 사용법을 파악하자&lt;/h2&gt;
&lt;p&gt;DBMS에 따라 특정 기능이나 좋은 성능을 보이는 해결책이 다르다. SQL문은 실행하기 전에 DBMS의 옵티마이저가 최적으로 수행할 수 있는 방법을 결정한다. 실행 계획을 생성해서 이를 결정하는데, 실행 계획에 따라 SQL문은 단계적으로 수행된다. 옵티마이저는 소스 코드를 실행 프로그래으로 변환하는 컴파일러로 볼 수 있는데, SQL 문을 실행 계획으로 변환한다. 특정 SQL 문에 대한 실행 계획을 보면 성능 문제를 식별하는 데 도움이 된다.&lt;/p&gt;

&lt;p&gt;실행 계획을 확인하고 해석하는 방법은 DBMS 관련 문서를 참고한다. MYSQL은 SQL 앞에  EXPLAIN 키워드를 붙여 실행 계획을 확인한다. 실행 계획에 나온 정보는 지나면 바뀔 수 있다는 점을 기억하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;쿼리 플랜의 작동 원리를 이해하자&lt;/h2&gt;
&lt;p&gt;실행 계획을 읽을 때마다 실행 계획을 물리적 동작으로 해석하며, 사용되지 않는 인덱스가 있는지 분석해 그 이유를 파악한다. 데이터베이스 시스템을 도서관, 필요한 데이터를 책이라고 보고 인덱스를 색인 카드라고 생각해보자. 필요한 책이 있을 때 해당 조건에 맞는 색인 카드가 없다면 책을 쉽게 찾을 수 없다. 원하는 조건에 따라 색인 카드를 추가로 만들어야 할 수도 있고, 여러 색인 카드를 조합해서 쉽게 책을 찾을 수 있는데, 색인 카드를 잘 활용하고 있지 못하는 경우도 있을 수 있다. 색인 카드가 제대로 활용되지 못하고 있다면 뭔가가 잘못 되었음을 알고 분석을 시작하면 된다.  다시 데이터 베이스 시스템 용어로 바꾸어 생각하면 다음과 같다,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;INDEX Seek : 색인 카드를 훑어보기&lt;/li&gt;
  &lt;li&gt;INDEX Scan: 색인 카드 덩어리를 뽑아내기&lt;/li&gt;
  &lt;li&gt;Key Lookup : 색인 카드에 포함되지 않은 추가 정보를 얻으려고 책장으로 가기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행 계획의 개별 단계를 분석하고 효율적인지를 판단해야 하는데, 효율성은 데이터 분포의 영향을 받는다. 이런 상황을 ‘코끼리와 쥐’ 상황이라고 한다, 결론적으로 ‘나쁜’ 연산이 아니라 쿼리에 적합한 연산이 무엇인지 분석해야 한다.&lt;/p&gt;

&lt;p&gt;좋은 실행 계획을 얻으려면 한 쿼리에 국한되지 않는 인덱스를 추가한다. 데이터베이스의 전반적인 가용성을 고려해 추가한 인덱스가 가능한 한 많은 쿼리에 적용되는지 확인한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=124421253&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/12442/12/cover/k802531656_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Mar 2018 09:12:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/28/9791160503425.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/28/9791160503425.html</guid>
        
        <category>sql</category>
        
        <category>queryplan</category>
        
        <category>explain</category>
        
        
        <category>DevBook</category>
        
      </item>
    
      <item>
        <title>DB에 누락된 정보를 로그에서 추출하여 수동 업데이트 하기</title>
        <description>&lt;h3 id=&quot;db-------&quot;&gt;DB에 누락된 정보와 실제 작업이 수행된 데이터 준비하기&lt;/h3&gt;
&lt;p&gt;물론 있어서는 안 되는 일이겠으나.. DB 장애 등으로 인해 데이터 업데이트를 실패하여 실제 어플리케이션 동작과 DB 데이터가 일치하지 않는 경우가 있었다. 어플리케이션 로그를 확인해서 DB 데이터를 수동으로 업데이트하면서 사용한 커맨드를 정리해봤다.&lt;/p&gt;

&lt;p&gt;로그를 분석해 실제 작업이 수행된 데이터를 real_executed.txt 파일에 추출하고 DB에 업데이트 되어 있는 데이터를 sql을 통해 추출하자. DB 클라이언트를 사용하고 있다면 csv 파일로 추출하기 어렵지 않다. 추출한 파일을 db_updated.csv 라고 하자. 두 파일은 아래와 같이 ‘\n’ 으로 구분되어 있도록 추출했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// real_executed.txt
a
b
c
d
e
...

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// db_updated.csv
a
b
c
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;db------&quot;&gt;실제 실행된 데이터에서 DB 결과를 제외해서 업데이트 실패한 데이터를 추출&lt;/h3&gt;
&lt;p&gt;real_executed.txt 와 db_updated.csv 를 동일한 포맷으로 추출했다면 diff 명령어를 통해 누락된 내용을 쉽게 파악할 수 있을 것 같다. 겉으로 보면 log에서 추출한 txt 파일이나, DB에서 추출한 csv 파일은 포맷이 동일하다. 하지만 csv 파일은 delimiter가 달라서 diff가 제대로 동작하지 않는다. 때문에 정석적으로는 csv 파일을 txt로 변환한 후 비교해야 하지만 이번에는 sort를 사용했다. sort를 하면 정렬과 함께 csv의 delimiter를 txt와 동일하게 바꾸어 주는 것으로 보인다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat real_executed.txt | sort -n &amp;gt; sorted_real_executed.txt
cat db_updated.csv | sort -n &amp;gt; sorted_db_updated.csv.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이제 diff를 통해 누락된 정보만 추출하자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff sorted_db_updated.csv.txt sorted_real_executed.txt &amp;gt; should_update.txt
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;db-update-&quot;&gt;누락된 발송 결과 DB에 Update 하기&lt;/h3&gt;
&lt;p&gt;누락된 정보를 추출한 후 DB에서 쿼리를 수행하기 위해서는 쿼리에 필요한 스트링으로 변환을 해야 한다. 사용하고 있던 업데이트문은 IN 절을 사용하고 있었기 때문에 “” 로 데이터를 감싸야 하고, ‘\n’ 을 ‘,’ 로 구분해야 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE alphabet_table
SET    status = &quot;SUCCESS&quot;,
WHERE  element IN (&quot;c&quot;, &quot;d&quot; ..... &quot;z&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat should_update.txt | awk '{print &quot;\&quot;&quot;$1&quot;\&quot;&quot;}' | tr '\n' , &amp;gt; sql_string.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;awk 로 쌍따옴표를 추가하고, ‘\n’을 컴마로 변경해주면 결과는 다음과 같다. 결과 스트링을 IN 절에 붙여 넣고 SQL을 실행시키면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;c&quot;,&quot;d&quot;,&quot;e&quot;, .... &quot;z&quot;,
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Mar 2018 09:00:59 +0900</pubDate>
        <link>http://underlinee.github.io/devlog/2018/03/28/missing-data-update.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devlog/2018/03/28/missing-data-update.html</guid>
        
        <category>diff</category>
        
        <category>sort</category>
        
        <category>awk</category>
        
        <category>tr</category>
        
        
        <category>DevLog</category>
        
      </item>
    
      <item>
        <title>이펙티브 SQL - 서브 쿼리</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;서브쿼리를 어디에 활용할 수 있는지 알아 두자&lt;/h2&gt;

&lt;p&gt;서브쿼리는 완전한 SELECT 문을 괄호로 둘러싸고 괄호 밖에는 AS절과 함께 별칭을 주는 것이다. 다른 SELECT, UPDATE, INSERT, DELETE 문 내의 여러 곳에 서브 쿼리를 사용할 수 있다.  서브 쿼리의 활용 방법을 정리하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테이블 서브쿼리 : 테이블이나 뷰의 이름, 테이블을 반환하는 저장 프로시저나 함수 이름을 사용할 수 있는 곳이라면 어디나 활용할 수 있다. 조인을 수행하기 전에 필터링이 필요한 FROM 절에서 특히 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT BeefRecipes.RecipeTitle
FROM (
    SELECT Recipes.RecipeID, Recipes.RecipeTitle
    FROM Recipes
        INNER JOIN Recipe_Ingredients
            ON Recipes.RecipeID = Recipe_Ingredients.RecipeID 
        INNER JOIN Ingredients
            ON  Ingredients.IngredientID = Recipe_Ingredients.IngredientID
WHERE  Ingredients.IngredientName = ‘Beef’
) AS BeefRecipes;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;단일 컬럼 테이블 서브 쿼리: 테이블 서브쿼리를 활용할 수 있다면 어디나 활용가능하다. 컬럼이 하나이므로 반환되는 칼럼은 IN 이나 NOT IN 조건의 목록을 제공하는 데 사용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스칼라 서브 쿼리: 단일 로우에 있는 한 컬럼에 값을 0개 또는 한 개만 반환한다. 단일 컬럼 테이블 서브쿼리나, 테이블 서브쿼리를 사용할 수 있는 곳에 모두 사용할 수 있다. 다른 컬럼 및 연산자와 함께 표현식에서도 사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;…
HAVING AVG(Product_Vendors.DaysToDeliver) &amp;gt; (
    SELECT AVG(DaysToDeliver)
    FROM Product_Vendors
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;연관성 있는 서브쿼리와 연관성 없는 서브쿼리의 차이점을 파악하자&lt;/h2&gt;

&lt;p&gt;연관성 없는 서브 쿼리는 주 쿼리에 있는 데이터에 의존하지 않으며, 독립적으로 수행될 수 있다. 일반적으로 FROM절의 필터링된 데이터 집합이나, WHERE 절의 IN 조건에 오는 단일 컬럼 데이터 집합으로 사용된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Recipes.RecipeTitle
FROM Recipes
WHERE Recipes.RecipeClassID IN (
    SELECT rc.RecipeClassID
    FROM Recipe_Classes AS rc
    WHERE rc.RecipeClassDescription IN 
        (’Salad’, ’Soup’, ‘Main course’)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;연관성 있는 서브쿼리는 WHERE 절이나 HAVING 절에서 주 쿼리가 제공하는 값에 의존하는 조건을 하나 이상 사용하는 서브쿼리다. 데이터베이스 엔진은 주 쿼리에서 반환되는 모든 로우에서 서브쿼리르 한 번씩 수행해야 하기 때문에 다른 방법에 대해 느리게 수행될 수 있으나, 데이터 베이스 시스템의 최적화로 항상 느리다고 할 수는 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Recipe_Classes.RecipeClassDescription, (
    SELECT COUNT(*)
    FROM Recipes
    WHERE Recipes.RecipeClassID =
        Recipe_Classes.RecipeClassID
    ) AS RecipeCount
FROM Recipe_Classes;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;서브쿼리 대신 조인을 사용해 더 효율적인 쿼리를 작성하자&lt;/h2&gt;

&lt;p&gt;주어진 문제를 절차적인 순서대로 분해해서 해결해야 바람직한 방법이라는 생각은 금물이다. SQL은 로우별이 아닌 데이터 집합을 대상으로 최적의 작업을 수행한다. 다양한 접근법을 어떻게 처리하는지 확인해서 DBMS의 옵티마이저가 선호하는 해결책으로 결정해야 한다. 일반적으로 IN 절에 서브쿼리를 사용하여 특정 데이터를 찾는 것 보다는 조인을 사용하는 것이 더 효율적이다. 데이터베이스 엔진은 조인에 대한 최적화를 더 잘 수행하기 때문이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT s.StyleNm
FROM Styles AS s
    INNER JOIN Countries AS c
        ON s.CountryFK = c.CountryID
WHERE c.CountryNM = &quot;Belgium&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=124421253&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/12442/12/cover/k802531656_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Mar 2018 09:11:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/27/9791160503425.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/27/9791160503425.html</guid>
        
        <category>sql</category>
        
        <category>subquery</category>
        
        <category>join</category>
        
        
        <category>DevBook</category>
        
      </item>
    
      <item>
        <title>java 스레드 덤프 분석 - 병목 지점 확인하기</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;스레드 덤프하기&lt;/h2&gt;
&lt;p&gt;batch 어플리케이션을 실행하는데 실행 속도가 점점 느려져서 스레드 덤프를 통해 병목 구간을 확인해봤다. 어플리케이션은 배치 작업으로 DB에서 데이터를 가져온 후 Queue에 넣는다. 어플리케이션 실행 후 로그 확인시 어플리케이션의 동작이 이루어지지 않은 것으로 보이는 (병목으로 추측되는!) 기간이 2분 가량 지속되었다.&lt;/p&gt;

&lt;h4 id=&quot;pid-&quot;&gt;pid 확인하기&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps -ef | grep java 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jstack---&quot;&gt;jstack 이용하여 스레드 덤프&lt;/h4&gt;
&lt;p&gt;병목 구간으로 추측되는 부분에서 스레드 덤프를 한다. 한 번으로 정확히 알 수 없기 때문에 여러번 스레드 덤프를 통해 결과를 비교하자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jstack -l pid &amp;gt;&amp;gt; threaddumps.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;스레드 덤프 내용 분석&lt;/h4&gt;
&lt;p&gt;어플리케이션이 Queue에서 데이터를 소비하는 Worker Thread는  WAITING 상태였고, DB에서 데이터를 가져오는 Repository 객체는 RUNNABLE인 상태였다. 
ExampleRepository.updateData() 메서드에서 병목인 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;자세한 분석 방법을 알고 싶다면 &lt;a href=&quot;http://d2.naver.com/helloworld/10963&quot;&gt;스레드 덤프 분석하기&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Worker Thread
&quot;ajp-bio-8009-exec-77&quot; #597 daemon prio=5 os_prio=0 tid=0x00007f901c00e000 nid=0x7965 waiting on condition [0x00007f90c91aa000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  &amp;lt;0x00000000abdc3cd0&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// RUNNABLE인 Repository 객체
&quot;ses-quartz-scheduler_Worker-5&quot; #16 prio=5 os_prio=0 tid=0x00007faaec6ff800 nid=0x1dcc runnable [0x00007faaa55de000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
        at java.net.SocketInputStream.read(SocketInputStream.java:171)
        at java.net.SocketInputStream.read(SocketInputStream.java:141)
        at com.mysql.jdbc.util.ReadAheadInputStream.fill(ReadAheadInputStream.java:112)
        at com.mysql.jdbc.util.ReadAheadInputStream.readFromUnderlyingStreamIfNecessary(ReadAheadInputStream.java:159)
        at com.mysql.jdbc.util.ReadAheadInputStream.read(ReadAheadInputStream.java:187)
        - locked &amp;lt;0x00000006ee4400e0&amp;gt; (a com.mysql.jdbc.util.ReadAheadInputStream)
        at com.mysql.jdbc.MysqlIO.readFully(MysqlIO.java:3158)
        at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3615)
        at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3604)
        at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4149)
        at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2615)
        at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2776)
        at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2840)
        - locked &amp;lt;0x00000006ee437d78&amp;gt; (a com.mysql.jdbc.JDBC4Connection)
        at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2082)
        - locked &amp;lt;0x00000006ee437d78&amp;gt; (a com.mysql.jdbc.JDBC4Connection)
        at com.mysql.jdbc.PreparedStatement.execute(PreparedStatement.java:1302)
        - locked &amp;lt;0x00000006ee437d78&amp;gt; (a com.mysql.jdbc.JDBC4Connection)
        at com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.execute(NewProxyPreparedStatement.java:989)
        at com.ibatis.sqlmap.engine.execution.SqlExecutor.executeUpdate(SqlExecutor.java:80)
        at com.ibatis.sqlmap.engine.mapping.statement.MappedStatement.sqlExecuteUpdate(MappedStatement.java:216)
        at com.ibatis.sqlmap.engine.mapping.statement.MappedStatement.executeUpdate(MappedStatement.java:94)
        at com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate.update(SqlMapExecutorDelegate.java:457)
        at com.ibatis.sqlmap.engine.impl.SqlMapSessionImpl.update(SqlMapSessionImpl.java:90)
        at org.springframework.orm.ibatis.SqlMapClientTemplate$9.doInSqlMapClient(SqlMapClientTemplate.java:383)
        at org.springframework.orm.ibatis.SqlMapClientTemplate$9.doInSqlMapClient(SqlMapClientTemplate.java:381)
        at org.springframework.orm.ibatis.SqlMapClientTemplate.execute(SqlMapClientTemplate.java:203)
        at org.springframework.orm.ibatis.SqlMapClientTemplate.update(SqlMapClientTemplate.java:381)
        at com.examples.application.repository.ExampleRepository.updateData(ExampleRepository.java:48)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;병목 구간 없애기&lt;/h4&gt;
&lt;p&gt;ExampleRepository.updateData() 는 배치 작업을 시작하기 전 데이터의 플래그를 변경하는 메서드인데, WHERE IN 절에 크기가 너무 큰 리스트가 들어가면서 성능상 문제가 생긴 것으로 확인했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// dataIds는 size가 10000인 list
repository.updateData(dataIds, STATUS.WORKING);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;dataIds를 나누어 처리하기 위해 Guava 의 Iterables를 사용했다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Iterable&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; patitionedDataIds = Iterables.partition(dataIds, 500);
for (List&amp;lt;String&amp;gt; dataIds : patitionedDataIds) {
    repository.updateData(dataIds, STATUS.WORKING);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 26 Mar 2018 09:43:59 +0900</pubDate>
        <link>http://underlinee.github.io/devlog/2018/03/26/java-threaddump.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devlog/2018/03/26/java-threaddump.html</guid>
        
        <category>java</category>
        
        <category>thread</category>
        
        <category>dump</category>
        
        <category>bottleneck</category>
        
        
        <category>DevLog</category>
        
      </item>
    
      <item>
        <title>이펙티브 SQL - 집계</title>
        <description>&lt;h2 id=&quot;group-by---&quot;&gt;GROUP BY 절은 간단하게 만들자&lt;/h2&gt;

&lt;p&gt;특정 유형으로 집계하려면 데이터를 분할해 그룹으로 묶어야 할 때가 종종 있는데, GROUP BY 절로 구현할 수 있다. 그런데 현재 SQL 표준에서 더는 요구하지 않지만 몇몇 DBMS에서는 집계되지 않는 칼럼을 GROUP BY 절에 추가해야 한다.  GROUP BY 절에 칼럼을 과도하게 기술하면 쿼리 성능에 악영향이 있을 뿐만 아니라 읽고 이해하기 어렵다. 따라서 집계와 세부 정보 조회 두 가지 목적을 달성해야 하는 쿼리를 작성할 때는 서브쿼리에서 모든 집계를 수행한 후 세부 데이터를 담은 테이블과 조인해 해당 정보를 가져온다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT c.Customer, c.CustState, c.Name, o.OrderCount
FROM Customers AS c
    LEFT JOIN (
        SELECT t.CustomerID, COUNT(t.OrderNumber) AS OrderCount
        FROM Orders AS t
        GROUP BY t.CustomerID
        ) AS o
    ON c.CustomerID = o.CustomerID;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;distinct-&quot;&gt;겹치지 않는 개수를 얻으려면 DISTINCT를 사용하자&lt;/h2&gt;
&lt;p&gt;COUNT() 집계 함수의 목적은 그 이름에서 유추할 수 있다. COUNT()의 용도는 세 가지로 구분할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COUNT(*) : 널 값과 중복된 값을 포함해 한 그룹의 항목 개수를 반환한다.&lt;/li&gt;
  &lt;li&gt;COUNT(ALL &lt;표현식&gt;) : 한 그룹의 각 로우에 있는 표현식을 평가해 NULL 이 아닌 값의 개수를 반환한다.&lt;/표현식&gt;&lt;/li&gt;
  &lt;li&gt;COUNT(DISTINCT &lt;표현식&gt;) : 한 그룹에 있는 각 로우에 대해 지정한 표현식을 평가해서 유일하고 널이 아닌 값의 개수를 반환한다.&lt;/표현식&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(*) AS TotalRows
    COUNT(DISTINCT CustomerID) AS TotalUniqueCustomer
    COUNT(CASE WHEN OrderTotal &amp;gt; 1000 THEN CustomerID END) AS TotalLargeOrders
    COUNT(DISTINCT CASE WHEN OrderTotal &amp;gt; 1000                 
    	THEN CustomerID END) AS TotalUniqCUST_LargeOrders
FROM OrdersTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=124421253&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/12442/12/cover/k802531656_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Mar 2018 09:01:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/26/9791160503425.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/26/9791160503425.html</guid>
        
        <category>sql</category>
        
        <category>groupby</category>
        
        <category>count</category>
        
        
        <category>DevBook</category>
        
      </item>
    
      <item>
        <title>이펙티브 SQL - 데이터 필터링과 검색</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;일치하지 않거나 누락된 레코드를 찾아내자&lt;/h2&gt;
&lt;p&gt;SQL을 사용해 데이터베이스에 없는 데이터를 조회할 때도 종종  있다. NOT IN 연산자는 이해하기 쉽지만 일반적으로 효율적인 접근은 아니다. NOT EXISTS 연산자를 사용하거나, Frustrated Join을 사용하자. NOT EXISTS와 Frustrated Join 중 더 효율적인 것은 DBMS에 따라 다르다. DBMS 쿼리 분석기로 최선의 방법을 찾아내자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT p.ProductNumber, p.ProductName 
FROM Products AS p LEFT JOIN Order_Details AS od
ON p.ProductNumber = od.ProductNumber
WHERE od.ProductNumber IS NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;날짜와 시간을 모두 포함하는 컬럼에서 날자 범위를 올바르게 검색하는 방법을 알자&lt;/h2&gt;
&lt;p&gt;언어 설정이나 날짜 형식에 따라 같은 값이 다른 날짜로 해석될 때가 있다. 이런 문제를 회피하려면 묵시적 날짜 변환 기능에 의존하지 않고 명시적으로 날짜 변환 함수를 사용하는 것이 좋다. 또 한가지 주의할 점은 BETWEEN이 포괄적 연산자라는 것이다. 이때 가능한 정확히 시간을 명시할 수도 있지만, DBMS에 따라 반올림이 다르게 동작하므로 BETWEEN을 쓰지 않고 &amp;gt;=, &amp;lt;= 연산자를 쓰는 편이 낫다. 또한 사용자가 2018-03-26, 2018-03-27 까지 조회하고 싶다면 DATEADD를 사용하는 편이 좀 더 명확해질 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WHERE Date &amp;gt;= 
    CONVERT(datetime, @startDate, 120)
AND DATE &amp;lt;
    CONVERT(datetime, DATEADD(DAY, 1, @endDATE) 120);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;데이터베이스 엔진이 인덱스를 사용하도록 사거블 쿼리를 작성하자&lt;/h2&gt;
&lt;p&gt;DBMS 엔진이 인덱스를 잘 활용하려면 쿼리의 서술 논리절이 인덱스를 사용해야 하는데 이것을 사거블(Search Argument Able) 이라는 용어로 표현한다. 사거블이 되지 않는 경우가 몇가지 있기 때문에 주의해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;WHERE 절에서 하나 이상의 필드에 대해 연산하는 함수를 사용하지 않는다.&lt;/li&gt;
  &lt;li&gt;WHERE 절에서 필드에 대한 수치 연산을 수행하지 않는다.&lt;/li&gt;
  &lt;li&gt;LIKE 연산자를 사용할 때 %문자는 검색 문자열 끝에 붙인다. %something% 은 넌사거블이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=124421253&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/12442/12/cover/k802531656_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Mar 2018 09:01:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/26/9791160503425.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/26/9791160503425.html</guid>
        
        <category>sql</category>
        
        <category>Frustrated_Join</category>
        
        <category>BETWEEN</category>
        
        <category>sargable</category>
        
        
        <category>DevBook</category>
        
      </item>
    
      <item>
        <title>gz 로그 파일 커맨드 라인으로 분석하기</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;로그 파일 분당 특정 로그가 나타나는 횟수 분석&lt;/h3&gt;
&lt;p&gt;어플리케이션에서 특정 동작이 단위 시간당 얼마나 일어나는지 확인할 필요가 있어서 사용했던 커맨드 라인을 정리했다.
로그 내용은 아래와 같고 분당 Working 갯수가 얼마나 되는지 확인해야 했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// application.log
2018-03-27 00:01:04,636 INFO  c.d.e.a.i.ExampleService - worker id=1724
2018-03-27 00:01:04,636 INFO  c.d.e.b.jobs.worker.ExampleWorker - Working
2018-03-27 00:01:04,636 INFO  c.d.e.b.jobs.worker.ExampleWorker - Working
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gz--log-&quot;&gt;gz 아닌 log 분석&lt;/h4&gt;
&lt;p&gt;Working을 grep 한 후 시간/분에 대해서 카운트 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tail -n 1000000 application.log | grep &quot;Working&quot; | cut -d ':' -f1,2 | uniq -c
   7252 2018-03-27 20:03
  10000 2018-03-27 20:04
  10000 2018-03-27 20:05
  10000 2018-03-27 20:06
  10000 2018-03-27 20:07
  10000 2018-03-27 20:08
  10000 2018-03-27 20:09
  10000 2018-03-27 20:10
  10000 2018-03-27 20:11
  10000 2018-03-27 20:12
  10000 2018-03-27 20:13
  10000 2018-03-27 20:14
  10000 2018-03-27 20:15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gz--log--1&quot;&gt;gz으로 압축된 log 분석&lt;/h4&gt;
&lt;p&gt;날짜가 지나면 압축되도록 설정해 두었다면 gz 파일을 열어봐야 하는데 귀찮은 일이다. gz 파일에 대해서 tail은 사용할 수 없고 zcat으로 일부만 확인할 수도 없댜. 
다행히 gzip에 좋은 옵션이 많았다. tail 앞에 gzip -cd 를 추가해 동일한 결과를 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// man gzip
... 
      -c --stdout --to-stdout
              Write  output  on standard output; keep original files unchanged.  If there are several input files, the output consists of a sequence of independently compressed
              members. To obtain better compression, concatenate all input files before compressing them.

      -d --decompress --uncompress
              Decompress.
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip -cd 2018-03-26.application.log.gz | head -n 1000000 application.log | grep &quot;Working&quot; | cut -d ':' -f1,2 | uniq -c
  10000 2018-03-26 00:00
  10000 2018-03-26 00:10
  10000 2018-03-26 00:13
   3261 2018-03-26 00:14
   6739 2018-03-26 00:15
   9275 2018-03-26 00:16
    725 2018-03-26 00:17
  10000 2018-03-26 00:18
  10000 2018-03-26 00:20
   2314 2018-03-26 00:21
   7686 2018-03-26 00:22
   8487 2018-03-26 00:23
   1513 2018-03-26 00:24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다만 gzip으로 head는 빠르게 확인 가능하지만, tail 만 확인할 수는 없다. 압축 알고리즘은 스트림에서 작동하며 스트림의 내용이 특정 지점 이전에 무엇인지 알지 못하면 해당 지점에서 압축 해제를 할 수 없다고 한다. &lt;br /&gt;
(참고 : https://stackoverflow.com/questions/1183001/how-can-i-tail-a-zipped-file-without-reading-its-entire-contents)&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Mar 2018 09:00:59 +0900</pubDate>
        <link>http://underlinee.github.io/devlog/2018/03/26/gzlog-analyze.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devlog/2018/03/26/gzlog-analyze.html</guid>
        
        <category>gz</category>
        
        <category>zcat</category>
        
        <category>tail</category>
        
        <category>log</category>
        
        
        <category>DevLog</category>
        
      </item>
    
      <item>
        <title>이펙티브 SQL - 데이터 모델 설계를 변경할 수 없는 경우</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;설계를 변경할 수 없을 때는 뷰로 데이터를 간소화하자&lt;/h2&gt;
&lt;p&gt;뷰는 하나 이상의 테이블이나 다른 뷰에 SQL 쿼리를 미리 정의해 놓고는 테이블처럼 데이터를 볼 수 있는 객체다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자에게 직관적인 데이터를 제공하려면 뷰를 사용한다.&lt;/li&gt;
  &lt;li&gt;사용자가 정확히 필요한 데이터를 보거나 더는 필요없는 데이터를 보지 않게 제한하려면 뷰를 사용한다.&lt;/li&gt;
  &lt;li&gt;복잡한 쿼리를 숨기고 재사용하려면 뷰를 사용한다.&lt;/li&gt;
  &lt;li&gt;여러 테이블에 있는 데이터를 취합해 보고용 데이터를 만들 때는 뷰를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE VIEW vCustomers AS
SELECT DISTINCT cs.CustFirstName, cs.CustLastName, cs.Address
From CustomerSales AS cs;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;요약 테이블을 만들어 관리하자&lt;/h2&gt;
&lt;p&gt;뷰를 이용하면 복잡한 쿼리를 단순화하고 데이터를 적절히 요약해 사용할 수 있다. 그런데 처리하는 데이터가 많다면 요약 테이블을 생성하는 것이 더 바람직할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;요약 데이터를 저장해 놓은 테이블을 사용하면 집계 작업을 할 때 좀 더 효율적으로 집계 데이터가 포함된 필드에 인덱스를 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;요약 작업은 다소 저적인 테이블에 적합하다. 원천 테이블이 빈번히 변경된다면 요약 작업의 부하는 무시할 수 없을 정도로 커진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;union--&quot;&gt;비규정화된 데이터를 언피벗하려면 UNION 문을 사용하자&lt;/h2&gt;
&lt;p&gt;UNION 쿼리는 두 개 이상의 SELECT 문으로 데이터 집합을 결합할 때 사용된다. UNION 쿼리를 사용할 때 적용되는 세 가지 규칙은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UNION 쿼리를 구성하는 각 쿼리의 컬럼의 개수가 동일해야 한다.&lt;/li&gt;
  &lt;li&gt;각 쿼리의 컬럼 순서도 일치해야 한다.&lt;/li&gt;
  &lt;li&gt;각 쿼리에서 사용된 컬럼의 데이터 타입도 일치하거나 서로 호환해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UNION 에서는 중복되는 로우를 제거하므로 주의해야 한다. UNION ALL 을 사용하면 중복되는 로우를 제거하는 단계가 사라지므로 성능 향상을 기대할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=124421253&quot;&gt;
  &lt;img class=&quot;book&quot; style=&quot;width: 30%; height: 30%&quot; src=&quot;http://image.aladin.co.kr/product/12442/12/cover/k802531656_1.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Mar 2018 09:10:59 +0900</pubDate>
        <link>http://underlinee.github.io/devbook/2018/03/25/9791160503425.html</link>
        <guid isPermaLink="true">http://underlinee.github.io/devbook/2018/03/25/9791160503425.html</guid>
        
        <category>sql</category>
        
        <category>union</category>
        
        <category>view</category>
        
        
        <category>DevBook</category>
        
      </item>
    
  </channel>
</rss>
