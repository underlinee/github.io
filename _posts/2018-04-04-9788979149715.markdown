---
layout: post
title:  "리팩토링 - 객체 간의 기능 이동"
date:   2018-04-04 00:00:59
categories: DevBook
tags:	리팩토링 refactoring 
---

기능을 넣을 적절한 위치를 찾는 문제는 **Move Method**와 **Move Field**를 실시해서 기능을 옮기면 해결된다. 보통 자신이 속한 객체보다 다른 객체를 더 많이 참조하는 것 같은 메서드를 찾아내서 다른 객체로 옮기면 된다. 두 기법을 모두 사용해야 할 때는 Move Field부터 실시한 후 Move Method를 실시하는 것이 좋다. 

클래스는 확실하게 추상화되어야 하며, 두세 가지의 명확한 기능만 담당해야 한다. 클래스가 방대해지는 원인은 대개 기능이 너무 많기 때문이다. 이럴 때는 **Extract Class**를 실시해서 기능 일부를 분리해야 한다. 만약 클래스에 기능이 너무 적어지면 **Inline Class**를 실시해서 한 클래스의 기능은 다른 클래스에 합친다. 

객체에서 핵심 개념 중 하나가 캡슐화다. 캡슐화하면 무언가를 변경할 때 그 변화를 전달해야 할 객체가 줄어들므로 변경이 쉬워진다. 클라이언트가 다른 클래스를 사용한다는 다른 말로 의존성이 생긴다는 것이다. 그 객체를 캡슐화하여 클라이언트로부터 감춘다면 변경시에 클라이언트로의 영향을 최소화할 수 있다. **Hide Delegate**를 실시하여 그 대리 클래스가 사용 중이라는 사실을 감추자. 하지만 장점도 얻는 대신 단점도 있다. 대리 클래스를 은폐하면 클라이언트가 대리 클래스의 새 기능을 사용하기 위해 간단한 위임 메서드를 계속 추가해야 할 때도 있는다. 이럴 때는 **Remove Middle Man**을 실시해야 한다. 

클래스 원본 코드에 접근할 수 없는 상황은 생각보다 흔하다. 이런 상황에서 수정해야할 기능이 한 두 개뿐일 땐 **Introduce Foreign Method**기법을 실시하고 메서드가 세 개 이상일 땐 **Introduce Local Extension** 기법을 실시한다. 국소 확장 클래스는 원본 클래스의 모든 기능도 사용 가능하면서 추가 기능도 들어 있다. 확장하는 기법은 **Subclassing** 과 **Wrapping**이 있다. 확장을 하면서 기능을 재정의한다면 나중에 애먹을 일이 생길 수 있다. 상속 확장 클래스를 사용할 땐 메서드를 재정의하지 말고 그냥 추가하자. 


<br/>

<a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=20793053">
  <img class="book" style="width: 30%; height: 30%" src="http://image.aladin.co.kr/product/2079/30/cover/8979149719_1.jpg"/>
</a>

