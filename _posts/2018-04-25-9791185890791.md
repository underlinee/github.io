---
layout: post
title:  "러닝 스칼라 - 객체, 케이스 클래스, 트레이트"
date:   2018-04-25 00:01:01
group: 책읽고밑줄
booklink: "http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=107218117"
bookimg: "http://image.aladin.co.kr/product/10721/81/cover/k012530750_1.jpg"
tags:	러닝스칼라 Scala
---

객체지향 설계를 할 때 클래스를 보완하고 변화를 주거나 클래스를 완전히 대체하는 데 사용할 수 있는 구성요소들이 있다. 

<br/>

## 객체
객체는 하나 이상의 인스턴스를 가질 수 없는 형태의 클래스로 new 키워드로 인스턴스를 생성하는 대신 이름으로 직접 해당 객체에 접근한다. 자바의 싱글턴과 비슷하지만 인스턴스화 가능한 클래스와 분리되어 있어 더 안전하고 이해하기 쉽다. 
```
object <식별자> [extends <식별자>] [{ 필드, 메소드, 클래스}]
```

- 객체의 최상위 레벨은 객체에 처음 접근하는 시점인 초기화시점에 호출되고 그 이후로는 호출되지 않는다. 
- 클래스의 메소드가 인스턴스의 필드를 읽어들이거나 쓰기 위한 것으로 데이터의 접근점과 비즈니스 로직을 보완한다면, 객체는 순수 함수와 외부 입출력 작업을 한다. 

<br/>

### Apply 메소드와 동반객체
객체도 클래스와 동일하게 apply 메소드를 정의하여 객체를 이름으로 호출할 수 있다. apply는 팩토리 패턴으로 사용되는 것이 가장 보편적인 사용법이다. 

동반객체는 클래스와 동일한 이름을 공유하고, 클래스와 동일한 파일 내에서 정의된다. 동반 객체와 해당 클래스는 접근 제어 관점에서는 하나의 단위로 간주되어 각각의 private/protected 변수에 동일하게 접근할 수 있다. 

```scala
class Multiplier(val x: Int) {def product(y: Int) = x * y}
object Multiplier{ def apply(x: Int) = new Multiplier(x) }

scala> val tripler = Multiplier(3)
```

<br/>

## 케이스 클래스
케이스 클래스는 자동으로 생성된 메소드 몇 가지를 포함하는 인스턴스 생성이 가능한 클래스다. 케이스 클래스는 자동으로 동반객체도 생성하는데 이 동반객체도 자동으로 생성된 메소드를 가지고 있다. 

- 케이스 클래스는 주로 데이터를 저장하는 데 사용되는 클래스인 DTO를 잘 지원한다. 
- 상속받은 필드에 대해서는 자동으로 생성된 메소드에 포함되지 않기 때문에 계층적인 구조에서는 잘 사용되지 않는다. 

```scala
case class Character(name: String, isThief:Boolean)
scala> val h = Character("Hadrian", true)
scala> val r = h.copy(name = "Royce")
scala> r == h
res0: Boolean = false
scala> h match { … }
```

<br/>

## 트레이트
트레이트는 다중 상속을 가능하게 하는 클래스 유형중 하나로 함수를 재사용하는 데 있어 편의성을 제공한다. 객체와 마찬가지로 클래스 매개변수를 취할 수 없지만, 타입 매개변수를 취할 수 있다는 점에서 차이가 있다. 

- 트레이트는 다중상속을 지원하는데 실제로 컴파일러는 각 트레이트의 사본을 이용하여 클래스와 트레이트의 긴 계층구조를 만들어 다중 상속을 지원하는 것과 마찬가지의 결과를 만든다. 이를 linearization이라고 한다. 
- linearization에서는 순서가 중요한데 가장 낮은 서브 클래스를 오른쪽에 배치한다. class C extends A with B 는 실제로 class C extends B extends A 이다. 

<br/>

### 셀프 타입
셀프 타입은 트레이트가 클래스에 추가될 때 특정 타입 또는 그 서브타입과 함께 사용되어야 함을 표시한다. 셀프 타입인 트레이트를 쓰기 위해서는 언제나 해당 타입을 부모 클래스 처럼 확장하는 것과 마찬가지이다. 셀프타입의 보편적인 용도는 입력 매개변수가 필요한 클래스에 트레이트로 기능을 추가하는 것이다. 
 
```
trait <식별자> { <식별자>: <타입> => …. }
```

```scala
class A { def hi = "hi"}
trait B { self: A =>
    override def toString = "B: " + hi
}
scala> class C extends A with B
scala> new C()
```

<br/>

### 트레이트를 이용하여 인스턴스화
트레이트를 사용하는 다른 방식으로 클래스가 인스턴스화될때 클래스에 트레이트를 추가하는 방법이 있다. 주의해야할 점은 클래스 인스턴스화 시점에 추가된 트레이트가 클래스를 확장한다는 점이다. 부모 클래스가 의존하는 실제 기능이 클래스가 인스턴스화될 때에 주입되기 때문에 DI라고 볼 수 있다. 스프링에서는 애너테이션으로 유사한 기능을 제공한다. 클래스를 정의 하는 것에 대한 대체 작업으로 개별 클래스를 정의하는 방식보다 유연하고 단순하다. 
```scala
class A
trait B

scala> new A with B
```

<br/>




