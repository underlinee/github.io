---
layout: post
title:  "자바 성능 튜닝 - 가비지 컬렉션 알고리즘"
date:   2018-02-25 00:10:59
categories: DevBook
tags:	Java 성능 가비지 GC 
---

## Parallel 컬렉터 이해하기
Parallel 컬렉터는 마이너 GC와 full GC 두 가지 동작을 한다. Young 컬렉션은 에덴이 가득 찼을 때 일어난다. 에덴이 비워지고, 일부는 서바이버 스페이스로, 일부는 올드 영역으로 옮겨진다. Old 컬렉션은 올드 제너레이션이 가득 찼을 때 일어나며, 올드 제너레이션의 앞 부분에 유효한 참조를 가진 객체를 옮기고 나머지를 비운다. 

#### Parallel 컬렉터 튜닝
Parallel 컬렉터 튜닝은 전체 힙 크기와 old/young 제너레이션 크기 사이의 균형 유지와 중단 시간에 대해 고려하면 된다. 여기서 고려해야 할 것은 시간과 공간에 대한 트레이드 오프다. 처리율을 높이기 위해서 더 큰 힙이 필요하며, 더 큰 힙을 사용하면 GC 처리에 걸리는 시간이 늘어난다. 

동적 힙 튜닝은 힙 크기를 조정하는 첫 단계이다. 적응 크기 적용을 허용하면 JVM이 가능한 최대 성능을 얻기 위해 힙 중단 시간 목표를 맞추기 위해 힙과 제너레이션의 크기 조절할 수 있다. -XX:MaxGCPauseMillis=N은 최대 허용 중단시간이며,  -XX:GCTimeRatio=N는 애플리케이션이 GC에 써도 되는 비율이다. 처리율 목표 = 1 - 1/(1 + GCTimeRatio) 로 값을 구한다. 비현실적인 MaxGCPauseMillis은 잦은 GC를 일으켜 상황을 악화시킬 수 있으니 주의한다.

<br/> 

## CMS 컬렉터 이해하기 
CMS는 마이너 GC와 동시 병렬 GC 작업을 한다. 동시병렬 주기에서는 old 영역이 어느정도 차면 백그라운드 스레드로 GC를 시작한다. 이 처리는 여러 단계로 나눌 수 있다. 
초기 Initial Mark 단계에서는 힙 내의 모든 GC 루트 객체를 찾는다.  멈추는 시간은 매우 짧다. Concurrent-Mark 단계에서 애플리케이션 스레드를 멈추지 않고 GC 루트 객체에서 참조하고 있는 객체들을 따라가며 표시한다. Preclean 단계와 abortable-Preclean 단계에서는 스레드를 동시 병렬로 수행하여 전처리 작업을 하는데 abortable-Preclean이 따로 있는 이유는 remark 단계가 마이너 GC와 연속되지 않게 하기 위해서다. remark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인 한다. 이후에는 sweep 단계에서 불필요한 객체를 수거한다. 그리고 reset 단계를 마지막으로 주기를 완료한다. 

#### CMS 컬렉터 튜닝
만일 마이너 GC가 일어났을때 old 제너레이션에 힙이 충분치 않거나 단편화 문제로 승격이 실패하면 full GC가 일어난다. 따라서 가능한 이런 문제가 일어나지 않도록 튜닝되어야 한다. 가장 쉬운 방법을 힙 크기를 늘리는 방법이다. 메모리 사용에 제약이 있다면 -XX:CMSInitiatingOccupancyFraction=N 과 -XX:+UseCmsIntiatingOccupancyOnly 를 설정하여 백그라운드 스레드를 더 자주 수행하거나 -XX:ConGCThreads=N 을 설정하여 스레드 수를 튜닝하는 것도 도움이 된다. 

<br/> 



## G1(Garbage First) 컬렉터 이해하기

G1은 힙 내의 개별 영역에서동시 병렬 컬렉터를 동작시킨다. 일부 영역이 다른 영역보다 많은 가비지를 포함하고 있다고 가정하고 가비지가 있는 영역만 집중적으로 비우기 때문에 GC가 빨리 끝난다. 각 영역은 old 나 eden, survivor 영역으로 나뉘어 있고, G1에서는 young 컬렉션, 동시 병렬 주기, 혼합 GC, 필요한 경우 full GC가 일어난다. 

eden 영역이 가득 차면 young 컬렉션이 일어난다. young 컬렉션에서 eden이 비워지고 suvivor 나 old로 옮겨지고 나머지는 해제 된다. 동시 병렬 주기에서는 초기 표시 - 루트 영역 스캔 - 표시 - 재표시 - 정상소거 단계로 진행되며, 실제 데이터를 해제 시키지는 않고 주로 가비지 영역을 표시한다. 혼합 GC 단계에서 가비지를 포함한 것으로 표시한 영역 대부분을 해제하고 나머지를 다른 영역으로 옮긴다. 객체 이동 중에 힙 압축이 일어나므로 G1은 CMS보다 단편화가 덜 일어난다. G1 GC도 full GC가 일어나는 경우가 있다. 표시 주기나 혼합 GC 중간에 old 영역이 가득차거나, young 컬렉션 후 살아남은 객체를 승격 시키지 못한 경우. 혹은 매우 큰 객체를 할당하는데 실패하는 경우다. 


#### G1 컬렉터 튜닝

G1 튜닝의 주요 목적은 full GC가 일어나지 않도록 하는 것이다. G1도 여러 튜닝을 적용할 수 있지만 너무 많은 튜닝을 하지 않도록 해야한다. 그래서 주로 합리적인 -XX:MaxFCPauseMillis=N을 정하는 것으로 튜닝을 한다. 여전히 문제가 발생한다면 백그라운드 스레드 수를 늘리거나, 더 자주 백그라운드 작업을 수행하거나, 혼합 GC 내에서 수집되는 영역을 늘리는 튜닝을 적용할 수 있다. 


<br/>


## 튜닝을 위한 질문들
- 애플리케이션이 full GC로 인한 중단을 겪어도 괜찮은가? : 괜찮다면 Parallel 컬렉터가 최고의 성능을 보인다. 아니라면 CMS와 G1을 고려하자
- 디폴트 설정으로 필요한 성능이 나오는가? : GC 기술이 성숙해지면서 자동 튜닝이 좋을 때가 많다.
- 중단 시간은 목표치에서 멀다면? : 최대 중단 시간만 조정해서 문제가 해결될 수 있다. 그렇지 않다면 제너레이션의 크기를 조정하자.
- 중단 시간은 짧은데 처리율이 떨어진다면? : 힙의 크기를 늘릴 필요가 있다.
- 동시 병렬 컬렉터를 사용하는데 old 영역이 가득차서 full GC가 일어난다면? : 스레드 수를 늘리거나 소거를 더 빨리 시작하자
- 동시 병렬 컬렉터를 사용하는데 승격 실패한다면? : 힙이 단편화 되었으므로 더 큰 힙을 쓰던가 소거를 더 빨리 해보자.

<br/>

<a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=79248318">
  <img class="book" style="width: 30%; height: 30%" src="http://image.aladin.co.kr/product/7924/83/cover/k542434036_1.jpg"/>
</a>