---
layout: post
title:  "리팩토링 - 코드의 구린내"
date:   2018-04-01 18:43:59
categories: DevBook
tags:	리팩토링 refactoring 
---

### 중복 코드
구린내의 제왕은 누가 뭐래도 중복코드다. 똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선된다. 

<br/>

### 장황한 메서드
최적의 상태로 장수하는 프로그램을 보면 공통적으로 메서드 길이가 짧다. 객체를 처음 접하는 개발자는 대부분 객체 프로그램을 보고는 기능도 거의 없는 메서드가 서로 끝없는 위임만을 일삼고 있다고 생각한다. 그러나 객체지향 프로그래밍 경험이 쌓일수록 그런 작은 메서드의 중요성을 실감하게 된다. 

<br/>

### 방대한 클래스
기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어 있다. 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다. 인수턴스 변수와 마찬가지로 코드 분량이 너무 방대한 클래스도 중복 코드가 많이 있기 마련이다. 

<br/>

### 과다한 매개변수
초보 시절 루틴에 필요한 모든 걸 매개변수를 사용해 전달하라고 배웠다. 당시 생각으론 이것이 당연했다. 왜냐하면 매개변수를 사용하지 않으면 그 대신 전역 데이터를 사용해야 하는데, 전역 데이터 사용은 바람직하지도 않을 뿐더러 어려움이 따른다는 사실을 알고 있었기 때문이다. 그러나 객체의 등장으로 인해 상황은 달라졌다. 필요한 데이터가 없을 때는 그것을 가져오도록 항상 다른 객체에 요청하면 되기 때문이다. 

<br/>

### 수정의 산발
개발자는 소프트웨어를 수정할 때 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다. 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정되는 것이다. 어떤 클래스를 보던 중 ‘새 데이터베이스 생성할 때마다 이 3개의 메서드를 수정해야 하고, 새 금융 상품을 추가할 때마다 이 4개의 메서드를 수정해야 하네!’ 하는 생각이 들면 그 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다.

<br/>

### 기능의 산재
기능의 산재는 수정의 산발과 비슷하지만 정반대다. 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다. 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 수정해야 하는 부분을 놓치기 쉽다. 

<br/>

### 잘못된 소속
객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다. 전통적으로 어떤 메서드가 자신이 속하지 않는 클래스에 더 많이 접근한다면 잘못된 소속의 구린내가 풍길 것이다. 

<br/>

### 데이터 뭉치
데이터 항목은 거리의 꼬마들처럼 몰려다니는 습성이 있다. 두 클래스에 들어 있는 인스턴스 변수나 여러 메서드 시그너처에 들어 있는 매개변수처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 겅우가 많다. 이렇게 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 

<br/>

### 강박적 기본 타입 사용
객체의 주요 장점 중 하나가 바로 기본 타입 클래스와 응용 클래스 간의 경계를 허문다는 점이다. 언어에 내장된 기본 타입과 구별하기 힘든 클래스를 손쉽게 작성할 수 있다. 객체를 처음 접하는 사람은 보통 숫자와 통화를 연동하는 돈 관련 클래스나 전화번호와 우편번호 같은 특수 문자열 클래스 등의 사소한 작업에 객체를 잘 사용하지 않으려는 경향이 있다

<br/>

### switch 문
switch 문의 단점은 반드시 중복이 생긴다는 점이다. 같은 switch 문이 프로그램 곳곳에 있을 때가 많다. switch 문에 새 코드 행을 추가하려면 그렇게 여기저기에 존재하는 switch 문을 전부 찾아서 수정해야 한다. 이 문제를 해결할 수 있는 최상의 방법은 다형성을 이용하는 것이다

<br/>

### 막연한 범용 코드
‘그래 조만간 이런 기능이 필요하겠구만’ 하는 막연한 생각에 아직은 필요 없는 기능을 수행하고자 온갖 호출과 case 문을 넣으려 하는 그 순간 막연한 범용 코드의 구린내가 풍긴다. 이 생각을 실천에 옮기면 대체로 코드를 알아보고 유지보수하기가 더 어려워진다. 

<br/>

### 임시 필드
어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다. 개발자는 객체가 그 안에 들어 있는 모든 변수를 이용하리라 생각하기 마련이므로 이런 코드는 파악하기 힘들다. 사용되지 않을 것 같은 변수가 어째서 거기 있는지 이해하려다 보면 스트레스를 받을 수 밖에 없다. 

<br/>

### 메시지 체인
메시지 체인은 클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 뜻한다. 이러한 메시지 체인은 수 많은 코드 행이 든 getThis 메서드나 임시변수 세트라고 봐도 된다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 사이의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다. 

<br/>

### 과잉 중개 메서드
객체의 주요 특징 한가지는 바로 캡슐화다. 그러나 이것도 지나치면 문제가 된다. 어떤 클래스의 인터페이스에서 그 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면 원리가 구현된 객체에 직접 접근하자.

<br/>

### 데이터 클래스
데이터 클래스는 필드와 필드 읽기/쓰기 메서드만 들어 있는 클래스다. 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 데이터 클래스는 어린애 같아서 처음엔 괜찮지만, 성숙한 객체로서의 역할을 하려면 어느정도의 책임을 감당해야 한다. 

<br/>

### 불필요한 주석
주석이 다 필요 없다거나 주석을 작성하지 말라는 얘긴 아니다. 오히려 구랜내가 아니라 향기라고 생각하니 오해하지 말자. 이 절에서 주석을 거론하는 이유는 주석이 구린내를 감춰주는 탈취제 용도로 쓰일 때가 많기 때문이다. 엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많다. 주석에는 돌아가는 원리, 확실치 않은 부분, 코드를 넣은 이유, 잊기 쉬운 사항 등을 적어 놓으면 사람들이 보고 쉽게 이해할 수 있다. 

<br/>

<a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=20793053">
  <img class="book" style="width: 30%; height: 30%" src="http://image.aladin.co.kr/product/2079/30/cover/8979149719_1.jpg"/>
</a>

