---
layout: post
title:  "Release It - 안정성 안티패턴"
date:   2018-02-07 16:43:59
categories: Book
tags:	ReleaseIt 아키텍쳐설계 소프트웨어배치 안정성  
---

## 통합 지점
모든 통합지점은 고장이 나기 때문에 이러한 고장에 대비하여 차단기와 분리하는 미들웨어 패턴을 사용한다. 
고장은 멋진 에러 응답 대신 다양한 종류의 프로토콜 위반, 느린 응답이나 완전한 행과 만나게 된다. 또한 애플리케이션 계층에서 디버깅하기가 쉽지 않은 경우가 많아 추상화된 계층이나 패킷, 네트워크 진단을 해야할 필요도 있다. 

<br/> 

## 연쇄 반응
서버 하나의 고장은 다른 서버에게 짐을 보태기 때문에 연쇄 반응을 일으킨다. 늘어난 부하 때문에 나머지 서버는 더욱 고장 나기 쉽다. 연쇄 반응은 곧 전체 계층을 고장 나게 할 것이다. 대부분은 메모리 누수가 연쇄 반응을 일으킨다. 한 서버가 메모리 누수를 겪으면 다른 서버도 마찬가지 문제가 있는 경우가 많고, 한 서버의 다운으로 메모리 누수가 더 빨리 진행된다. 이러한 연쇄 반응을 막기 위해 차단기 패턴을 사용하자. 

<br/> 

## 연속적인 고장
연속적인 고장은 크랙이 한 시스템이나 한 계층에서 다른 곳으로 도약할 때 일어나는데, 대개 통합지점에서 심각한 문제가 생길 수 있다고 생각하지 않기 때문이다. 연속적인 고장은 커넥션 풀과 같은 리소스 풀에서 자주 일어난다. 요청에 대한 응답을 할 수 없을 때 고갈되어 블록되며, 연결을 기다리는 다른 스레드도 블록된다. 차단기는 문제가 생긴 통합지점에 대한 호출을 피하므로써 시스템을 보호하며 제한 시간을 사용하여 문제가 생긴 지점을 호출하는 것에서 빠져나올 수 있다. 

<br/> 

## 사용자들
사용자의 세션마다 메모리가 필요하다. 용량 향상을 위해 세션 메모리를 최소화하자. 현실의 사용자들은 예측할 수 없는 행동을한다. 악의적인 사용자들도 존재하며 때로는 떼지어 시스템을 공격할지도 모른다. 보안 관련 공부를 하고 부하 테스트를 실시해야 한다. 

<br/> 

## 블록된 스레드
애플리케이션 고장은 어떤 방식으로든 블록된 스레드와 항상 관련되는데, '점진적인 속도 둔화'나 '행이 걸린 서버'도 포함한다. 블록된 스레드 안티패턴은 리소스 풀에서 일반적으로 일어나는데 특히 데이터베이스 연결 풀에서 일어난다. 이런 상태의 방어를 위해 교착 상태가 없도록 제한 시간이 없는 wait()을 삼가고, 확인할 수 없는 서드파티 코드를 테스트해야 한다. 

<br/> 

## 자기부정공격
자기 부정 공격은 여러분 조직 안에서 유래하는데, 똑똑한 마케터가 자초하기도 한다. 무엇이 올 지 아는 경우에만 시스템을 보호할 수 있다. 대량의 첫번째 클릭에 대비하여 정적인 '착률 지대'를 만들자. 트래픽이 급증하면 프로그래밍 에러, 예상치 못한 확장 효과, 공유 자원 모두가 위험을 초래한다. 앞 단의 증가되는 트래픽은 기하급수적으로 뒷단의 프로세싱을 증가시킨다. 

<br/> 

## 확장 효과
일대일 개발과 테스트 환경에서 거대한 실전 환경으로 옮겨갈때 확장효과에 발등을 찍힐 수 있다. 연결의 개수는 일대일 일 경우 참여자 숫자의 제곱으로 늘어나기 때문에 조심해야 한다. 수십대의 서버를 다룬다면 일대다 통신과 같은 것으로 일대일 통신을 교체할 필요가 있을 수 있다. 공유 자원은 병목 구간이나 용량 제한, 안정성에 위협이 될 수 있다. 공유 자원을 반드시 사용해야 한다면 부하 테스트를 실시하자. 

<br/> 

## 불균형 용량 
QA 시스템에서 시스템과 그 시스템을 호출하는 다른 시스템은 한 개나 두 개로 보일지도 모르지만 실전에서 이 비율은 십대일 이상일지도 모른다. 앞단과 뒷단 서버의 비율을 검토하자. 불균형 용량은 확장 효과의 특별한 경우다. 관계 속에서 한 편을 다른 편에 비해 크게 늘린 경우다. 뒷단 시스템에 대한 호출이 응답을 멈추거나 느려진다면 어떤일이 일어나는지를 미리 살펴보자. 

<br/> 

## 느린 응답
응답 시간이 상위 시스템의 제한 시간을 초과할 때 느린 응답을 경험하는 상위의 시스템들도 느려지면 안정성 문제가 취약해진다. 웹 사이트의 경우 느린 응답은 새로고침 버튼을 자주 클릭하여 과부하가 걸린 시스템에 트래픽을 더 많이 발생시킨다. 만약 시스템이 응답성을 추적한다면 허용된 시간을 초과할때 즉각 에러 반응을 보내는 것을 고려하자. 이런 느린 응답은 흔히 데이터베이스 연결 부족이나 메모리 누수로 인한 가비지 컬렉터의 과도한 작업으로 일어난다. 

<br/> 

## 끝이 없는 쿼리결과
객체로 결과가 변하는 백만 개의 열을 돌려주는 쿼리를 할 때 무슨일이 벌어지는지 파악해야 한다. 부수적인 혜택으로 성능 테스트도 함께 할 수 있다. 어떤 쿼리가 몇 개 안되는 결과만 돌려준다고 예상될지라도 시스템의 다른 부분 때문에 경고도 없이 바뀔 수 있다. 또한 xml-rpc 같은 프로토콜은 엄청난 양의 객체를 돌려받아 메모리를 너무 많이 소비할 수 있다. 

<br/> 

<a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=1006539">
  <img class="book" style="width: 30%; height: 30%" src="http://image.aladin.co.kr/product/100/65/cover/8992939108_1.jpg"/>
</a>
