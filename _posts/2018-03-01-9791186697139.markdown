---
layout: post
title:  "자바 성능 튜닝 - 힙 메모리 베스트 프랙티스"
date:   2018-02-28 00:10:59
categories: Book
tags:	Java 힙 
---

## 힙 분석
어떤 객체가 메모리를 소비하고 있는지 아는 것이 힙 분석의 첫 단계다. 
히스토그램은 전체 힙 덤프 없이 애플리케이션 내의 많은 객체를 빨리 살펴볼 수 있는 방법이다. 
- % jcmd pid GC.class_histogram : 힙 히스토그램 확인
- % jmap -histo pid : GC 대상이 되는 객체를 포함한다.
- % jmap -histo:live pid : full GC를 강제로 일으킨다

<a href="//underlinee.github.io/assets/20180301-1.png" data-lightbox="falcon9-large">
  <img src="//underlinee.github.io/assets/20180301-1.png"/>
</a>

심도 있는 분석이 필요하다면 덤프를 생성하는 편이 낫다. 
- % icmd pid GC.heap_dump /path/to/heap_dump.hprof
- % map -dump:live, file=/path/to/heap_dump.hprof pid

<br/>

## 메모리 부족 에러
#### 네이티브 메모리 부족
JVM이 사용할 수 있는 네이티브 메모리가 없는 상황에서 발생한다. 에러 메시지는 "unable to create new native thread" 이다
#### 메타스페이스 메모리 부족
단순히 애플리케이션이 기본 퍼머넌트 크기보다 더 많은 클래스를 사용할 것일 수도 있지만, 클래스로더 메모리 누수일 가능성도 있다 에러 메시지는 "Metaspace" 혹은 "PermGen space" 이다. 
#### 힙 메모리 부족
힙 자체에 실제로 메모리가 부족할 때 발생한다. 단순히 힙 공간을 늘려주는 것으로 문제가 해결될 때도 있으나, 메모리 누수를 겪고 있을 가능성도 있다. 어느 경우에나 힙 덤프를 분석해서 대부분의 메모리를 소비하는 것이 무엇인지 찾을 필요가 있다. 에러 메시지는 "Java heap space" 이다. 
#### GC 오버헤드 한계
JVM이 GC를 수행하는 데 시간이 너무 오래 걸린다고 판단한 경우다. full GC가 다섯 번 이상 연속으로 발생하면서 각 GC마다 98% 이상의 시간을 GC에 사용하고 힙의 %2가 해제되지 않으면 이 에러가 발생한다. 
에러 메시지는 "GC overhead limit exceeded" 다. 

<br/>

## 메모리 적게 사용하기
#### 객체 크기 줄이기
객체는 일정 크기의 힙 메모리를 차지하므로 메모리를 적게 사용하려면 객체를 더 작게 만드는 방법이 간단하다. 객체는 8byte 경계에 맞춰 채워지고 참조 크기는 JVM이 32/64에 따라 다르다. 

#### 객체의 지연 초기화 
객체를 생성하는데 변수를 사용하지 않는 경우가 많다면 지연 초기화로 메모리를 절약할 수 있다. 연관된 코드가 스레드 세이프해야 하면 느린 초기화 처리는 복잡해지고 병목의 원인이 될 가능성도 생긴다. 동기화로 인한 병목이 생긴다면 이중 검사 방식을 사용해서 해결할 수 있다. 

#### 정규 객체 사용하기
불변인 객체가 빨리 생성되고 폐기되면 young 컬렉션에 영향을 준다. 이런 객체를 정규화해서 복사본을 만들지 않고 사용하면 애플리케이션이 사용하는 힙의 양을 감소시킬 수 있다. 이때 메모리 누수를 막기 위해 약한 참조를 사용해야한다. 

<br/>

## 객체 생명 주기 관리
#### 객체 재사용
객체 재사용은 범용 작업으로는 권장되지 않지만 초기화 비용이 비싼 객체의 그룹이 작은 경우는 적합할 수 있다. 객체 풀을 통해 객체를 재사용하거나 스레드 로컬 변수를 사용하는 경우에는 트레이드 오프를 고려해야 한다. 
객체풀은 GC의 효율을 감소시키며 동기화가 필요한 경우 경쟁이 많이 생겨 초기화보다도 접근이 느려질 수 있다. 하지만 DB 풀 같이 희소자원에 대한 접속을 제어하는 유용한 방법으로 사용할 수 있다. 스레드 로컬 변수는 항상 스레드 내에서만 사용하고 명시적으로 반환할 필요가 없어 객체 풀 보다 관리가 쉽고, 단일 스레드에서만 사용할 수 있어 동기화가 필요없다. 그리고 스레드와 객체 수 사이에서 1:1 관계를 갖게 된다.

#### Week 참조와 Soft 참조
참조를 더 자세히 구별하여 GC 때의 동작을 다르게 지정할 수 있게 되었다. 다시 말해, GC 대상 여부를 판별하는 부분에 사용자 코드가 개입할 수 있게 되었다. Soft 참조는 최근에 사용된(LRU) 객체를 담고 있는 캐시 풀이다. 시기에 맞춰 GC가 된다면 성능 향상을 기대할 수 있다. 해당 객체가 Soft 참조 외에는 가지고 있지 않으며 메모리가 넉넉하지 않다면 GC 대상이 된다. -XX:SoftRefLRUPolicyMSPerMB 값을 늘리면 GC 대상이 되도록 하는 기준 시간이 늘어난다. 기준 시간 동안 접근하지 않은 객체는 GC 대상이 된다. Week 참조는 어떤 객체가 WeakReference를 제외하고 참조하는 곳이 존재 하지 않을 경우 GC 의 대상이 된다. 그래서 때문에 반환될 가능성이 너무 크다. 여러 스레드가 동시의 해당 객체를 사용할 때 고려하자. WeakRef 를 사용하면, 예상하기 힘든 각종 참조와 버그와 불필요한 객체가 삭제되지 않아, 메모리가 낭비되는 것을 막을 수 있다. 

<br/>

<a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=79248318">
  <img class="book" style="width: 30%; height: 30%" src="http://image.aladin.co.kr/product/7924/83/cover/k542434036_1.jpg"/>
</a>