---
layout: post
title:  "자바 성능 튜닝 - 가비지 컬렉션 입문"
date:   2018-02-24 00:10:59
group: 책읽고밑줄
booklink: "http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=79248318"
bookimg: "http://image.aladin.co.kr/product/7924/83/cover/k542434036_1.jpg"
tags:   자바성능튜닝 java GC
---

## 가비지 컬렉션 개요
자바의 매력 중 하나는 개발자가 명시적으로 객체의 생명주기를 관리할 필요 없이 객체가 더 이상 사용되지 않을때 JVM이 자동으로 객체를 해제 시킨다. JVM이 정기적으로 미사용 객체가 있는 힙을 찾아 메모리를 해제하고 추가 객체를 할당하는데 사용하도록 가용 메모리를 생성하고 힙을 압축한다. GC의 성능은 각각의 구현체가 미사용 객체 찾기, 가용 메모리 생성, 힙 압축을 어떤 접근 방식으로 구현했느냐에 따라 달라진다. 그리고 GC는 애플리케이션 로직과 다른 스레드에서 실행되는데, GC가 객체 참조를 추적하거나, 메모리에서 객체를 옮긴다면 애플리케이션 스레드에서 해당 객체를 사용하지 않아야 한다. 그래서 GC 동안 애플리케이션 스레드가 중지되고 이를 stop the world라고 한다. 

### 제너레이션
모든 가비지 컬렉터는 별도의 제너레이션으로 나누는 근거는 단기간만 객체가 이용된다는 가정에 따라 힙을 old와 young 제너레이션으로 나눈다. 이 설계는 성능상 두 가지 이점이 있다. 첫째로 young 제너레이션은 전체 힙의 일부이기 때문에 전체 힙이 처리되는 것보다 더 빠르며, 둘째로 young 제너레이션이 가득차서 비워지게 되면 young 제너레이션은 따로 압축 처리를 할 필요가 없다. 모든 GC 알고리즘은 young 제너레이션이 일어나는 동안 stop the world를 발생시킨다. 반면 old 제너레이션이 가득 차면 full GC가 일어나는데 알고리즘에 따라 큰 차이점이 있다. 단순한 GC에서는 full GC에서도 모든 애플리케이션 스레드를 중지시키지만, CMS, G1 GC는 애플리케이션 스레드가 실행되는 동안 GC 처리를 한다. 그래서 동시 병렬 컬렉터라고 불린다. 동시 병렬 컬렉터의 트레이드 오프는 애플리케이션이 CPU를 더 사용할 것이라는 점이다. 

### GC 알고리즘
- 시리얼 가비지 컬렉터: 힙 처리에 단일 스레드를 사용하고 힙이 처리되는 동안 stop the world가 일어난다. full GC 동안 old 제너레이션이 완전이 완축된다. 
- 병렬 컬렉터 (parallel collector): young 제너레이션을 수집할 때 여러 스레드를 사용하여 마이너 GC가 빨라진다. 힙이 처리되는 동안 stop the world가 일어난다.  full GC 동안 old 제너레이션이 완전이 완축된다. 대부분 상황에서 디폴트이다. 
- CMS 컬렉터: full GC 동안 애플리케이션 스레드를 멈추기 않고 아주 잠시 동안 백그라운드 스레드가 old 제너레이션의 처리를 한다. 백그라운드 스레드는 압축을 하지 않으므로 힙이 단편화 될 수 있는데, 단편화가 너무 많이 일어나면 full GC에서  stop the world가 일어난다.
- G1 컬렉터 : 힙을 여러 개의 영역으로 나누어 young 영역은 병렬 스레드로 처리하고, old 영역 처리시 애플리케이션 스레드를 멈추지 않고 백그라운드 스레드에서 한 영역을 다른 영역으로 복사해서 old 제너레이션 처리하면서 CMS의 문제인 단편화를 해결한다. 

병렬 컬렉터는 CMS 컬렉터보다 평균 응답시간이 빠르지만 병렬 컬렉터가 full GC를 과도하게 일어날 경우 CMS보다 낫고, CMS는 병렬 컬렉터에 비해 아주 느린 응답이 적다. 힙이 작을때는 CMS가 G1 보다 성능이 좋지만, CMS의 단편화로 인한 full GC가 일어날 수 있으므로 힙이 큰 경우 G1이 성능이 좋다. 

<br/> 

## 기본 GC 튜닝

### 힙 크기 정하기
힙이 너무 작다면 GC가 자주 일어나지만 큰 힙을 지정하는게 답인 것도 아니다. GC에 걸리는 시간은 힙이 커지면 늘어난다. 매우 큰 힙을 사용할 때 만약 OS의 가상 메모리를 사용하여 swap이 일어난다면 심각한 성능상 불이익이 일어난다. 만약 GC 중에 swap이 일어난다면 stop the world가 몇 배는 더 길어진다. 따라서 JVM의 총 힙은 물리 메모리를 넘지 않아야 한다. 힙 초기 크기와 최대 크기는 -XmsN -XmxN 으로 정할 수 있는데 JVM이 GC가 너무 많이 일어 난다면 알맞은 GC 수를 유지하기 위해 힙을 늘린다. 만약 필요한 힙의 크기를 정확히 안다면 초기값과 최대값을 그 값으로 정하자. 힙 크기를 재조정할 필요가 없기에 약간 더 효율적이 된다. 

### 제너레이션의 크기 정하기
young 제너레이션의 크기가 크다면 마이너 GC가 비교적 적게 일어나고 full GC는 더 많이 일어난다. 제너레이션 크기를 적절히 설정해서 이 균형을 유지해야 한다. 
- XX: NewRatio=N : old와 young 비율 설정, 초기 힙 크기 / (1 + NewRatio) 가 young 영역의 비율이 된다. 
- XX: NewSize=N: young 초기 크기 설정
- XX: NewMaxSize=N: young 최대 크기 설정
- XmnN : NewSize와 NewMaxSize를 동일한 값으로 설정


### 메타스페이스 크기 정하기
메타스페이스(java8) 혹은 퍼머넌트 제너레이션(java 7)은 클래스 메타데이터를 가지고 있다. 퍼머넌트 제너레이션/메타스페이스가 가득 차면 기존 클래스 메타 데이터가 폐기될 때 full GC가 일어나기 때문에 모든 클래스가 로드된 후의 사용량을 기준으로 이 영역의 초기값을 정하면 스타트업 시간이 약간 빨라지게 된다. 

### 병렬성 제어하기
Serial 컬렉터를 제외한 GC 알고리즘은 여러 개의 스레드로 GC 작업을 한다. JVM은 머신의 CPU 개수를 기반으로 GC 스레드 수를 정하는데 , CPU 당 스레드를 8개까지 사용하고 임계치에 다다르면 CPU 한 개당 5/8개의 신규 스레드만 추가한다. GC 스레드는 매우 효율적으로 CPU를 사용하기 때문에 지나치게 많은 스레드가 생성되지 않도록 머신에 한 개 이상의 JVM 이 실행되면 모든 JVM에 대해 GC 스레드 개수를 제한 하는 편이 좋다. 

<br/> 

## GC 도구
GC 모니터링하는 방법은 로그,  jconsole과 jstat을 이용한 실시간 모니터링이 있다. 로그 활성화는 간단한 로그는 -verbose:gc, -XX:+printGC 를 사용하고 -XX:PrintGCDetails 로 좀 더 상세한 로그를 남긴다. jconsole은 UI로 실시간 그래프를 볼 수 있으며 jstat은 스크립트 형태로 GC의 비율과 GC 처리 시간을 볼 수 있다. 


<a href="//underlinee.github.io/assets/img/20180224-1.png" data-lightbox="falcon9-large">
  <img src="//underlinee.github.io/assets/img/20180224-1.png"/>
</a>

S0~P는 각각의 영역의 사용률을 보여주며, YGC/FGC GC 횟수,  YGCT/FGCT GC 처리 시간을 나타낸다.

<br/>